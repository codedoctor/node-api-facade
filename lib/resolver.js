// Generated by CoffeeScript 1.4.0
(function() {
  var Resolver, async, convertToObject, _,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  _ = require('underscore');

  async = require('async');

  /*
  Necessary to bypass nastynesses from libs like mongoose
  */


  convertToObject = function(item) {
    if (item.toObject && _.isFunction(item.toObject)) {
      return item.toObject();
    }
    return item;
  };

  module.exports = Resolver = (function() {

    function Resolver() {
      this._mergeObjectBack = __bind(this._mergeObjectBack, this);

      this._afterResolve = __bind(this._afterResolve, this);

      this.resolve = __bind(this.resolve, this);

      this._addResolverToFunctions = __bind(this._addResolverToFunctions, this);

      this.add = __bind(this.add, this);

      this.normalizeName = __bind(this.normalizeName, this);
      this.matrix = {};
      this.embedMe = {};
    }

    Resolver.prototype.normalizeName = function(name) {
      return name = name.toLowerCase();
    };

    Resolver.prototype.add = function(kind, idOrIds, target, embed) {
      var collection, id, _i, _len, _results;
      if (embed == null) {
        embed = false;
      }
      kind = this.normalizeName(kind);
      if (!idOrIds) {
        return;
      }
      if (!_.isArray(idOrIds)) {
        idOrIds = [idOrIds];
      }
      collection = this.matrix[kind];
      if (!collection) {
        collection = this.matrix[kind] = {};
      }
      _results = [];
      for (_i = 0, _len = idOrIds.length; _i < _len; _i++) {
        id = idOrIds[_i];
        if (collection[id]) {
          collection[id].push(target);
        } else {
          collection[id] = [target];
        }
        if (embed) {
          _results.push(this.embedMe[id.toString()] = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    /*
      Closure needed for this one.
    */


    Resolver.prototype._addResolverToFunctions = function(resolverMap, options, kind, collection, functions) {
      var objectIds, resolver,
        _this = this;
      resolver = resolverMap[kind];
      objectIds = _.keys(collection);
      if (resolver && _.isArray(objectIds) && objectIds.length > 0) {
        return functions.push(function(cb) {
          return resolver.resolve(kind, objectIds, options, cb);
        });
      }
    };

    Resolver.prototype.resolve = function(resolverMap, rootObject, options, client, cb) {
      var collection, functions, kind, _ref,
        _this = this;
      if (options == null) {
        options = {};
      }
      if (cb == null) {
        cb = function() {};
      }
      functions = [];
      _ref = this.matrix;
      for (kind in _ref) {
        collection = _ref[kind];
        this._addResolverToFunctions(resolverMap, options, kind, collection, functions);
      }
      if (functions.length > 0) {
        return async.parallel(functions, function(err, results) {
          if (err) {
            return cb(err);
          }
          return _this._afterResolve(results, rootObject, options, client, cb);
        });
      } else {
        return cb(null, rootObject);
      }
    };

    Resolver.prototype._afterResolve = function(results, rootObject, options, client, cb) {
      var c, id, k, keys, r, t, val, _i, _j, _len, _len1, _ref, _ref1,
        _this = this;
      if (results == null) {
        results = [];
      }
      for (_i = 0, _len = results.length; _i < _len; _i++) {
        r = results[_i];
        r.items = r.items || {};
        _ref = r.items;
        for (k in _ref) {
          val = _ref[k];
          r.items[k] = convertToObject(val);
        }
        keys = _.keys(r.items);
        keys = _.filter(keys, function(x) {
          return _this.embedMe[x];
        });
        if (keys.length > 0) {
          if (!rootObject._embedded) {
            rootObject._embedded = {};
          }
          if (!rootObject._embedded[r.collectionName]) {
            rootObject._embedded[r.collectionName] = {};
          }
          c = rootObject._embedded[r.collectionName];
          for (_j = 0, _len1 = keys.length; _j < _len1; _j++) {
            k = keys[_j];
            c[k] = client.mapObjectSync(r.kind, r.items[k], options, null);
          }
        }
        /*
              We need to merge this back. Each r looks like
              r =
                kind: ...
                collectionName: 'users'
                items: {} where the index into the items is the string/lowercased object id
        */

        _ref1 = this.matrix[r.kind] || {};
        for (id in _ref1) {
          t = _ref1[id];
          this._mergeObjectBack(id, t, r.kind, r.items, options, client);
        }
      }
      return cb(null, rootObject);
    };

    Resolver.prototype._mergeObjectBack = function(objectId, mergeTargets, kind, itemsCollection, options, client) {
      var resolved, targetObject, _i, _len, _results;
      if (mergeTargets == null) {
        mergeTargets = [];
      }
      if (itemsCollection == null) {
        itemsCollection = {};
      }
      _results = [];
      for (_i = 0, _len = mergeTargets.length; _i < _len; _i++) {
        targetObject = mergeTargets[_i];
        if (!!targetObject) {
          if (itemsCollection[objectId]) {
            options.scopes = ['inline'];
            resolved = client.mapObjectSync(kind, itemsCollection[objectId], options, null);
            _results.push(_.extend(targetObject, resolved));
          } else {
            _results.push(void 0);
          }
        }
      }
      return _results;
    };

    return Resolver;

  })();

}).call(this);
